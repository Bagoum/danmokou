using System;
using System.Collections;
using System.Collections.Generic;
using BagoumLib;
using BagoumLib.Culture;
using BagoumLib.Functional;
using BagoumLib.Mathematics;
using BagoumLib.Transitions;
using Danmokou.Behavior;
using Danmokou.Core;
using Danmokou.DMath;
using Danmokou.GameInstance;
using Danmokou.UI.XML;
using Unity.Properties;
using UnityEngine;
using UnityEngine.UIElements;
using static Danmokou.UI.XML.XMLUtils;

//generic data source using default data binding
public class ValueDataSrc<T> : UIViewModel {
    private readonly Delayed<T> val1;
    /// <summary>
    /// Example property read from an underlying data source.
    /// Note that the CreateProperty attribute is required so
    ///  <see cref="Unity.Properties.Internal.ReflectedPropertyBagProvider.GetPropertyMembers"/>
    ///  picks up this property.
    /// </summary>
    [CreateProperty] public T Value => val1.Value;
    //no error is thrown for two-way binding if a setter is missing, but behavior may be unpredictable,
    // since the UI field will be set anyways and may not be updated to the "correct" underlying value
    // until the hash code changes.
    
    //TODO/NB: Computed properties of the underlying data source (eg. generating an LString based on score)
    // can be included in the data source class, but should NOT be included in the view hash code!
    // Otherwise, that could generate garbage every frame!
    
    public ValueDataSrc(Delayed<T> val) {
        val1 = val;
    }
    
    //Called every frame
    //We can't use autogenerated record GetHashCode because it only includes *backed* fields- ie. fields +
    // auto-properties, but not manually implemented properties, even if they have a getter and setter.
    //Additionally, the data binder's GetHashCode *will* be used internally for data binder identity checks,
    // so it would be a bad idea to have it just return the data hash code!
    //As such, use classes instead of records
    public override long GetViewHash() {
        return EqualityComparer<T>.Default.GetHashCode(Value);
    }
}

//Custom label binding. Note that practically speaking you can't share one CustomBinding object -
// the internal logic that checks dirty/data source changed will fire whenever this binding is used
// for more than one data source.
//As such, I'm implementing this by taking the node and data source as arguments, and doing a pretty
// raw UXML write.
//Note that by implementing IDataSourceProvider, we don't need to specify dataSource on the source UXML object.
public class CustomLabelView<T> : UIView, IDataSourceProvider {
    private UINode n;
    private ValueDataSrc<T> data;
    public CustomLabelView(UINode n, ValueDataSrc<T> data) : base(data) {
        this.n = n;
        this.data = data;
        updateTrigger = BindingUpdateTrigger.OnSourceChanged;
    }

    protected override BindingResult Update(in BindingContext context) {
        Logs.Log("updating custom binding");
        n.NodeHTML.Q<Label>().text = data.Value!.ToString();
        return base.Update(in context);
    }

    public object dataSource => data;
    public PropertyPath dataSourcePath => new PropertyPath();
}



public static class MHelpers {
    private static Binding deflt = new DataBinding();

    static MHelpers() {
        //We don't require an LString converter since its ToString works fine, but we could specify one
        //(deflt as DataBinding)?.sourceToUiConverters.AddConverter((ref LString x) => "ls:" + x.Value);
    }
    public static UINode BindLabel<T>(this UINode n, ValueDataSrc<T> dataSrc, string path) {
        //return n.WithView(n => new CustomLabelView<T>(n, dataSrc));
        
        n.OnBuilt = n.OnBuilt.Then(n => {
            var l = n.NodeHTML.Q<Label>();
            l.dataSource = dataSrc;
            l.dataSourcePath = new PropertyPath(path);
            l.SetBinding("text", deflt);
        });
        return n;
    }

    public static UINode BindString(this UINode n, string val) =>
        BindLabel<string>(n, new(val), nameof(ValueDataSrc<string>.Value));
}
public class LocalXMLDataBindingExample : CoroutineRegularUpdater {
    
    private XMLDynamicMenu menu = null!;
    private UIGroup g1 = null!;
    private LString mydata1 = RNG.RandStringOffFrame(5);
    private Label tmp_label = null!;
    
    public override void FirstFrame() {
        menu = ServiceLocator.Find<XMLDynamicMenu>();
        var s = menu.MainScreen;
        g1 = new UIColumn(new UIRenderExplicit(s, _ => {
            var col = s.Container.AddColumn();
            col.ConfigureAbsolute().WithAbsolutePosition(1920, 1080);
            col.style.width = 800;
            col.style.height = 600;
            col.style.justifyContent = Justify.Center;
            return col;
        }), new UINode().BindString("hello world"));
        menu.FreeformGroup.AddGroupDynamic(g1);
        g1.AddNodeDynamic(new UINode().BindString("foobar"));

        var dataSrc = new ValueDataSrc<LString>(new(() => this.mydata1));
        g1.AddNodeDynamic(new UINode().BindLabel(dataSrc, nameof(ValueDataSrc<LString>.Value))
            .PrepareTooltip("this is a tooltip!"));
        
        g1.AddNodeDynamic(new FuncNode(null, n => {
            var p = PopupUIGroup.CreatePopup(n, "Popup",
                r => new UIColumn(r, new UINode("basic popup description")
                        { Prefab = Prefabs.PureTextNode })
                    { Interactable = false },
                new PopupButtonOpts.LeftRightFlush(null, new UINode[] {
                    new UIButton("OK", UIButton.ButtonType.Confirm, UIButton.GoBackCommand(n))
                }));
            return p;
        }).BindString("this node has a popup"));
        g1.AddNodeDynamic(new UINode()
            .BindString("this node has a menu (C)")
            .PrepareTooltip("this is a tooltip!")
            .PrepareContextMenu(ContextMenu));

        UINode[] ContextMenu(UINode n, ICursorState cs) {
            return new[] {
                new UINode("another one").PrepareContextMenu(ContextMenu),
                new FuncNode("go to previous node", () => new UIResult.GoToNode(n.Group, n.Group.Nodes.IndexOf(n) - 1)),
                new FuncNode("delete this node", () => {
                    var ind = n.Group.Nodes.IndexOf(n);
                    n.Remove();
                    return new UIResult.GoToNode(n.Group, ind);
                })
            };
        }
    }

    [ContextMenu("Modify string1")]
    public void ModifyData1() {
        Logs.Log($"Updated string data to {mydata1 = RNG.RandStringOffFrame(5)}");
    }
    [ContextMenu("Modify label text")]
    public void ModifyLabelText() {
        Logs.Log($"Updated label text to {tmp_label.text = RNG.RandStringOffFrame(5)}");
    }

}
