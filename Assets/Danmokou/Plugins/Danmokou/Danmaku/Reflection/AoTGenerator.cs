using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using BagoumLib;
using BagoumLib.Expressions;
using BagoumLib.Mathematics;
using BagoumLib.Reflection;
using Danmokou.Core;
using Danmokou.DMath;
using Danmokou.Expressions;
using Scriptor.Compile;
using Scriptor.Reflection;
using UnityEngine;

namespace Danmokou.Reflection {
public static partial class Reflector {
#if UNITY_EDITOR
    private static readonly Type[] autogenGenerics = {
        typeof(float), typeof(bool), typeof(Vector2), typeof(Vector3),
        typeof(Vector4), typeof(V2RV2)
    };

    private static string GenerateFile(IEnumerable<string> funcs) => $@"//----------------------
// <auto-generated>
//     Generated by Danmokou reflection analysis for use on AOT/IL2CPP platforms.
//     This file ensures that generic methods used by reflection are properly generated by the AOT compiler.
// </auto-generated>
//----------------------

using System;

namespace Danmokou.Reflection {{
public static class AoTHelper_CG {{
    public static void UsedOnlyForAOTCodeGeneration() {{
        {string.Join("\n\t\t", funcs)}

        throw new InvalidOperationException();
    }}

}}
}}
";

    public static void GenerateAoT() {
        List<string> funcs = new();
        var typePrinter = new CSharpTypePrinter { PrintTypeNamespace = _ => true };
        void AddConstructedMethod(MethodInfo mi, Type[] typArgs) {
            var typeDecl = typePrinter.Print(mi.DeclaringType!);
            if (!mi.IsStatic)
                typeDecl = $"default({typeDecl})";
            var type_prms = string.Join(", ", typArgs.Select(typePrinter.Print));
            var args = string.Join(", ", mi.GetParameters()
                .Select(p => p.ParameterType == typeof(string) ? "\"\"" : "default"));
            funcs.Add($"{typeDecl}.{mi.Name}<{type_prms}>({args});");
        }
        foreach (var (gmib, ts) in GenericMethodSignature.specializeCache
                     .Select(kv => (Mi: kv.Key.Item2.Member, kv.Key.Item1))
                     .Distinct()
                     .OrderBy(g => g.Mi.BaseMi.Name)) {
            if (gmib is TypeMember.Method gmi) {
                AddConstructedMethod(gmi.Mi, ts.Data);
            } else
                throw new Exception($"Can't bake {gmib.GetType()}");
        }
        FileUtils.WriteString(CookingContext.outputPath + "AoTHelper_CG.cs", GenerateFile(funcs));
    }
    
#endif
}
}