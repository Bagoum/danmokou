<#> warnprefix
pattern({
	##boss simp.kasen
})
phase(0)
	paction(0)
		shift-phase-to(1)

!{ power1()
sync powerup1 <> poweraura boss1
	lerp 0 1 t red pink
	orange
!}

<!> type non nest
<!> hp 1000
phase 0
	paction 0
		## Not exposing loop2 produces error "The given key '0' was not present in the dictionary." after 1 second
		bullet-control persist circle-*/w restyle circle-blue/ &(> t 1, = &.loop2 0)
		
		bullet-control persist circle-green/w sm(onlyonce > t 1, 
			## Not exposing loop2 produces error "No float loop2 in bullet GCX" after 1 second
			async ellipse-orange/w <> gcr2 12 4 <> { } s tprot pxy(-2 - sine(7p, 0.7, &loop1), &loop2)
		)
		
	
		async circle-*/w <> gcr2 24 _ <3> {
			bindItr loop1
		} gsr2c 2 {
			color { red green }
			bindItr loop2
			##expose { f loop2 } ## This works via some very funky internal stuff, 
										## where the expose list is cascaded down to GCXU as the AST is constructed
										## It actually won't work if you call the functions in code!
		} simple
			##expose { f loop2 } ## VTP.Expose: This works very normally, by simply referencing the variable and allowing
											## the auto-compiler to include it
			rvelocity px (2 + sine(7p, 0.7, &loop1)) {
				scale(
				##expose { f loop2 } ## Same principle as VTP.Expose. You only need to expose it in one place.
				1 + 0.2 * t)
			}


